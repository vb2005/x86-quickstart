# Основы работы со внешними зависимостями

Assembler - мощное средство для разработки. Однако при разработке под x86, естественно, применяются языки более высокого уровня. Они позволяют создавать более читаемый, более простой и универсальный программный код. Однако, при всех преимуществах языков высокого уровня есть ситуации, в которых требуется гарантировать определённое поведение программного кода или задействовать дополнительные возможности CPU, которые компилятор/интерпретатор может "забыть". В этом случае и приходит на помощь Assembler. Критические фрагменты кода могут быть оформлены в виде подпрограмм, написанных на ассемблере, представленных в виде библиотек и интегрированных в требуемый язык программирования. При этом ОС загрузит код библиотеки в RAM и будет выполнять его с высокой скоростью

## Windows ABI x86_32

При обращении к функциями C/C++ на Windows в коде ассемблера необходимо следовать некоторым соглашениям, которые требует ОС - Microsoft Windows ABI (Application Binary Interface). Эти соглашения определяют, как данные передаются в функции и как результат возвращается из функции. Эти соглашения общие для семейства ОС Windows, однако в Linux они другие (System V ABI). Также эти соглашения отличаются в разных разрядностях ОС.

Рассмотрим соглашение Windows API x32(x86)
1. Аргументы функции в обратном порядке заносятся в стек.
2. Если значение передаётся по ссылке, то в стек заносится её указатель
3. На структуры, массивы в стек записывается указатель на начало объекта
4. Результат работы функции записывается в регистр eax

Таким образом, если мы хотим вызвать функцию 
``` cpp
int Hello(int* array, int count, char* str);
```

Мы должны выполнить следующие операции
``` asm
push array
push count
push str
call Hello
```
Некоторые ассемблеры (например, masm) позволяют использовать C-стиль вызова функций INVOKE Hello, array, count, str



## Импорт функции

Все используемые в коде функции должны быть явно объявлены в начале программы через оператор extern

``` asm
extern _Hello
```

## Объявление переменных

Для удобства работы, опишите все константы заранее в блоке .data

``` asm
section .data
hello 	db "Hello, World", 0
arr 	dw 123, 456, 789, 9012, 3456, 6789
cnt		dw 6
```

## Вызов функции

Заносим в стек все значения в обратом порядке и вызываем функцию



## Сборка проекта

Сборка в объектный код ничем не будет отличаться от сборки файла без зависимостей.
Отличия будут в процессе сборки в исполняемый файл. Необходимо подключить к проекту .lib-файл с информацией об используемых функциях.

Также исполняемый файл не запустится, поскольку не сможет найти dll с реализацией функции. Положите её в каталог приложения или добавьте его в переменные окружения.



Часто возникает ситуация, когда Вы не знаете, как выглядит та или иная функция. Чтобы получить по ним информацию, вы можете использовать программу dumpbin. Она выпишет все зависимости вашей библиотеки, а также напишет, какие функции доступны к использованию из вашего файла

Рассмотрим взаимодействие с программой dumpbin.exe. Программа предоставляет сведения о структуре исполняемого файла или библиотеки.

dumpbin.exe <Имя_файла> /ALL
Выводит сведения и содержимое по каждой секции кода программы

dumpbin.exe <Имя_файла> /IMPORTS
Выводит информацию по используемым внешним зависимостями

dumpbin.exe <Имя_файла> /EXPORTS
Выводит информацию по доступным внешним функциям


## Взаимодействие Assmebler -> DLL -> C#

Рассмотрим процесс создания динамической библиотеки и её использования в языках высокого уровня. 

```
global _calculator
export _calculator

; Экспорт внешней функции
extern _MessageBoxA@16


section .data
hello 	db "Hello, World", 0
caption db "Caption", 0

section .text
_calculator:
	push 1					; Код кнопок на сообщении
	push caption			; Заголовок окна
	push hello				; Текст содержимого
	push 0					; Указатель на дескриптор основного окна
	call _MessageBoxA@16 	; Вызов функции
	ret

```

```
link 2.obj /out:2.dll legacy_stdio_definitions.lib ucrt.lib user32.lib /dll /NOENTRY
```

Проверим, доступна ли наша функция при помощи 
```
Dumpbin.exe 2.dll /EXPORTS
```

Данный код позволил нам сгенерировать файлы .lib и .dll которые потребуются для использования функции в других языках программирования.

Несколько важных моментов:
1. Мы собрали библиотеку под Windows x86_32. Она не будет работать в контексте 64-битных интерпретаторов и компиляторов. Поэтому при её использовании проверяйте версии проектов и интерпретаторов.
2. В библиотеке отсутствует заголовочный файл. Заголовки функции придётся прописывать в явном виде
3. 


1. Создайте пустой проект C/C++
2. Укажите использовать архитектуру Win32 и режим запуска Debug
3. Добавьте пустой файл cpp и добавьте в него следующее содержимое:

```
extern "C"  void  calculator();

int main() {
	calculator();
	return 0;
}
```

4. В настройках проекта перейдите в раздел Каталоги VC++ -> Каталоги библиотеки. В нем добавьте путь в .lib-файлу, полученному в результате сборки библиотеки
В разделе Компоновщик -> Ввод -> Дополнительные зависимости, укажите имя .lib файла (без пути до него)
5. Нажмите F5, убедитесь, что приложение собирается. 
6. Добавьте в каталог с исполняемым файлом динамическую библиотеку (файл .dll) и повторите запуск



Теперь рассмотрим несколько важных моментов:
1. Конструкция extern "C" требуется для того, чтобы сборщик не генерировал суффиксы к имени функции на этапе сборке
2. Библиотеки на C/C++ должны сопровождаться заголовочными .h файлами. В данном случае, а нас их нет. Вместо него, используется 1 строка. Мы сами определяем порядок и формат аргументов. Кроме того, мы можем менять его по своему назначению. Заголовок будет лишь определять то, что ОС положит в стек перед запуском нашей программы.

Измените тип возвращаемого значения на int, и посмотрите, что выводит данная функция в качестве результата. Объясните полученные значения


1. Создайте проект консольного приложения C#
2. Измените платформу запуска на Win32. Для этого Диспетчер конфигураций -> Платформа -> Создать -> x86
3. Добавьте следующий программный код:
```
using System.Runtime.InteropServices;


[DllImport(@"C:\temp\2.dll")]
static extern void calculator();


calculator();
```
4. Запустите проект, убедитесь, что он работает


## Взаимодействие Assmebler -> DLL -> Python
Для решения данной задачи нам потребуется интерпретатор Python 32 бита
from ctypes import *
lib = CDLL('test')
lib.calculator()




1. Создайте пустой проект
2. Добавьте в него пустой файл .cpp
3. Измените тип проекта на Общие -> Тип конфигурации -> Динамическая библиотека
4. Добавьте программный код:
```
extern "C" __declspec(dllexport)
		int FindMin(int a, int b, int c) {
		if (a < b) {
			if (a < c) return a;
			if (c < b) return c;
		}

		if (c < b) return c;
		return b;
	}
```
