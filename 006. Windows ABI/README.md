# Основы работы со внешними зависимостями

**Assembler** - мощное средство для разработки. Однако при разработке под x86, естественно, применяются языки более высокого уровня. Они позволяют создавать более читаемый, более простой и универсальный программный код. Однако, при всех преимуществах языков высокого уровня есть ситуации, в которых требуется гарантировать определённое поведение программного кода или задействовать дополнительные возможности CPU, которые компилятор/интерпретатор может "забыть". В этом случае и приходит на помощь Assembler. Критические фрагменты кода могут быть оформлены в виде подпрограмм, написанных на ассемблере, представленных в виде библиотек и интегрированных в требуемый язык программирования. При этом ОС загрузит код библиотеки в RAM и будет выполнять его с высокой скоростью

## Windows ABI x86_32

При обращении к функциями C/C++ на Windows в коде ассемблера необходимо следовать некоторым соглашениям, которые требует ОС - **Microsoft Windows ABI** (Application Binary Interface). Эти соглашения определяют, как данные передаются в функции и как результат возвращается из функции. Эти соглашения общие для семейства ОС Windows, однако в Linux они другие (System V ABI). Также эти соглашения отличаются в разных разрядностях ОС.

Рассмотрим соглашение Windows ABI x32(x86)
1. Аргументы функции в обратном порядке заносятся в стек.
2. Если значение передаётся по ссылке, то в стек заносится её указатель
3. На структуры, массивы в стек записывается указатель на начало объекта
4. Результат работы функции записывается в регистр eax

Таким образом, если мы хотим вызвать функцию 
``` cpp
int Hello(int* array, int count, char* str);
```

Мы должны выполнить следующие операции
``` asm
push array
push count
push str
call Hello
```
Некоторые ассемблеры (например, masm) позволяют использовать C-стиль вызова функций 
``` asm
INVOKE Hello, array, count, str
```

## Использование системных функций
Контекст ОС Windows содержит тысячи реализованных функций упрощающих взимодейсвтие с устройствами и ОС в целом. Данный контекст называется **Windows API (WinAPI)**.  Самые известные библиотеки из нее:
```
kernel32.dll
avdapi32.dll
user32.dll
gdi32.dll
```

Эти библиотеки являются интерфейсом для взимодействия с ядром операционной системы. Они не меняются уже десятки лет и служат надежным и доступным средством для взимодействия с практически всеми приложениями Windows. Мы в своей программе также попытаемся подключить одну из функций библиотеки `user32.dll` - `MessageBox`.
Данная функция выводит на экран диалоговое окно с заданными параметрами.
Подробная информация о функции доступна здесь: (Microsoft Learn)[https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox]

Заголовок функции выглядит следующим образом:
``` c
int MessageBox(
  [in, optional] HWND    hWnd,
  [in, optional] LPCTSTR lpText,
  [in, optional] LPCTSTR lpCaption,
  [in]           UINT    uType
);
```
#### Функция принимает 4 аргумента и возвращает ответ - индекс нажатой кнопки

hWnd - Дескриптор окна родительского приложения создаваемого окна сообщения. Если этот параметр имеет значение 0, окно сообщения создаётся без связи с другими окнами


lpText - Отображаемое сообщение. Если строка состоит из нескольких строк, строки можно разделить с помощью символа возврата каретки и (или) перевода строки между каждой строкой.

lpCaption - Заголовок диалогового окна. Если этот параметр имеет значение 0, по умолчанию используется название Error.

uType - Содержимое и поведение диалогового окна. Этот параметр может быть сочетанием флагов из следующих групп флагов. (Подробнее тут)[https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox]

## СБорка программы с возможностями Windows API
### Импорт функции

Все используемые в коде функции должны быть явно объявлены в начале программы через оператор `extern`

``` asm
extern _MessageBoxA@16
```

### Объявление переменных


Для удобства работы, опишите все константы заранее в блоке `.data`

Нам потребуются название диалогового окна и текст содержания

``` asm
section .data
content 	db "Do you know what WinAPI is?", 0
caption 	db "Some Question", 0
```

### Вызов функции

Заносим в стек все значения в обратом порядке и вызываем функцию

``` asm
section .text
_main:
	push 1				; Код кнопок на сообщении
	push caption			; Заголовок окна
	push content			; Текст содержимого
	push 0				; Указатель на дескриптор основного окна
	call _MessageBoxA@16 		; Вызов функции
	ret
```

### Сборка проекта

Сборка в объектный код ничем не будет отличаться от сборки файла без зависимостей. Еще раз обращу внимание, что мы используем 32-битный контекст и сборку следует проводить с соотвествующими флагами.
```
nasm.exe -f win32 1.asm -o 1.obj
```

Отличия будут в процессе сборки в исполняемый файл. Необходимо подключить к проекту ```.lib``` файл с информацией об используемых функциях. Эти файлы обычно не поставляются вместе с ОС и их необходимо скачивать отдельно. Однако, здесь выручает Visual Studio, который любезно положил все необходимые ```.lib``` файлы в SDK разработчика. Каталоги SDK уже включены в окружение, поэтоми писать их явно нет необходимости. Собираем проект:
```
link 1.obj /subsystem:console /entry:main /out:1.exe user32.lib
```

Не забудьте добавить библиотеки в каталог к ```.exe``` файлу, в противном случае, программа выдаст ошибку при запуске. Все ```.dll``` файлы, используемые приложением должны быть или вместе с ним в одном каталоге, или располагаться в переменных окружения. В нашем случае делать этого не нужно, поскольку папка ```C:\Windows\System32```, в которой лежит user32.dll, входит в перемнные окружения. 

## Утилита DumpBin

Часто возникает ситуация, когда Вы не знаете, как выглядит та или иная функция. Чтобы получить по ним информацию, вы можете использовать программу ```dumpbin```. Она выпишет все зависимости вашей библиотеки, а также напишет, какие функции доступны к использованию из вашего файла

Рассмотрим взаимодействие с программой ```dumpbin.exe```. Программа предоставляет сведения о структуре исполняемого файла или библиотеки.
```
dumpbin.exe <Имя_файла> /ALL
```
Выводит сведения и содержимое по каждой секции кода программы

```
dumpbin.exe <Имя_файла> /IMPORTS
```
Выводит информацию по используемым внешним зависимостями

```
dumpbin.exe <Имя_файла> /EXPORTS
```
Выводит информацию по доступным внешним функциям

Используя возможности данной программы, посмотрите, какие функции предоставляют библиотеки ```kernel32.dll```, ```user32.dll```, ```gdi32.dll```, ```advapi.dll```


# Основы взимодействия с другими языками программирования
## Разработка библиотеки на Assembler

Рассмотрим процесс создания динамической библиотеки и её использования в языках высокого уровня. Библиотека, в отличие от исполняемого файла не имеет функции main, однако должна иметь некоторые функции, помеченные директивой ```export```. Такие функции будут доступны к вызовы извне. Помините, что в Assebmler не функций в явном виде. Есть только подпрограммы. Аргументы подпрограмм в нашем случае - это значения из стека. Результат работы функции - значение из ```EAX```. Давайте реализуем функцию, которая будет выдавать диалоговое окно. За основу возьмём старый проект и немного его модернизируем.

``` asm
global _dialog
export _dialog

; Экспорт внешней функции
extern _MessageBoxA@16


section .data
hello 	db "Hello, World", 0
caption db "Caption", 0

section .text
_dialog:
	push 1					; Код кнопок на сообщении
	push caption				; Заголовок окна
	push hello				; Текст содержимого
	push 0					; Указатель на дескриптор основного окна
	call _MessageBoxA@16 			; Вызов функции
	ret

```

Здесь мы заменили _main на _dialog и пометили его как доступный к использованию ```export```. Теперь соберем этот файл известными коммандами:
```
nasm.exe -f win32 1.asm -o 1.obj
link 1.obj /dll /NOENTRY /out:1.dll user32.lib 
```
Здесь появляется 2 новых флага: ```/noentry``` - собирать без точки входа и ```/dll``` - собирать как библиотеку. В результате этих двух команд в рабочем каталоге появятся 3 файла:

```
1.dll - динамическая библиотека
1.lib - файл связывания (импорта)
1.exp - файл описания экспортируемых функций
```

Проверим, доступна ли наша функция:
```
Dumpbin.exe 1.dll /EXPORTS
```

Сохраните себе два файла - ```1.dll``` и ```1.lib```. Они нам пригоднятся для запуска функции из других языков программирования.
В результате мы собрали библиотеку под Windows x86_32. Она не будет работать в контексте 64-битных интерпретаторов и компиляторов. Поэтому при её использовании проверяйте версии проектов и интерпретаторов.

## Интеграция в C/C++

Рассмотрим вариант интеграции на примере среды разработки Microsoft Visual Studio и компилятора Microsoft Visual C++ Runtime.
Если Вы раньше писали программы для C/C++, то наверняка знаете, что для подключения внешних библиотек необходимы 3 составляющих:
1. Динамическая библиотека (```.dll``` файл)
2. Статическая библиотека или библиотека импорта (```.lib``` файл)
3. Заголовки функций (```.h``` файл)

И если первые 2 пункта здесь есть, то заголовочный файл придётся "сочинять" самому. Данное слово тут неслучайно. В заголовке Вы можете укзаать любое количество аргументов и любой тип возвращаемого значения. Главное, что если вы потом эти данные извлекаете в Assembler, то сами знали, что оттуда будет извлечено.

1. Создайте **пустой проект C/C++**
2. Укажите использовать архитектуру Win32 и режим запуска Debug
3. Добавьте файл ````.cpp``` со следуующим содержимым:

``` cpp
extern "C"  void  dialog();

int main() {
	dialog();
	return 0;
}
```

4. В настройках проекта укажите:
В разделе ```Каталоги VC++``` -> ```Каталоги библиотеки``` добавьте полный путь к каталогу где лежит наш ```.lib``` файл
В разделе ```Компоновщик``` -> ```Ввод``` -> ```Дополнительные зависимости``` укажите имя ```.lib``` файла (без пути до него)
5. Нажмите ```F5```, убедитесь, что приложение собирается. 
6. Добавьте в каталог с исполняемым файлом динамическую библиотеку (файл ```.dll```) и повторите запуск

Несколько моментов:
1. Конструкция ```extern "C"``` требуется для того, чтобы сборщик не генерировал суффиксы к имени функции на этапе сборке. Чем они плохи можете убедиться самостоятельно, удалив 
2. Библиотеки на C/C++ должны сопровождаться заголовочными ```.h``` файлами. В данном случае, а нас их нет. Вместо него, используется 1 строка. Правилом хорошего тона, безусловно, будет создать этот файл отдельно и определить в нем порядок следования аргументов и тип возвращаемого значения. 

## Интеграция в C#

C# имеет механизм **P/Invoke** для вызова функций из динамических библиотек. При этом достаточно добавить в аннотации полный путь к библиотеке и сделать соотвествующий заголовок.
Рассмотрим также на примере **Microsoft Visual Studio**, компилятор **.NET 8.0**
1. Создайте проект **консольного приложения C#**
2. Измените платформу запуска на Win32. Для этого зайдите в ```Диспетчер конфигураций``` -> ```Платформа``` -> ```Создать``` -> ```x86```
3. Добавьте следующий программный код:
``` csharp
using System.Runtime.InteropServices;

[DllImport(@"C:\temp\1.dll")]
static extern void dialog();

dialog();
```
4. Запустите проект, убедитесь, что он работает

Если проект при запуске выдаёт ошибку "Попытка загрузить программу имеющую неверный формат", то проверьте путь к библиотеки и разрядность запускаемого приложения.

## Интеграция в Python

В Python есть библиотека для удобного связывания - ```ctypes```. Она предлагает механизмы взаимодействия с проектами на Asm/C/C++. При этом библиотеки должны быть собраны именно под требуемую разрядность интерпретатора. Поскольку у нас они x86_32 (А Python на ПК вряд ли такой разрядности), в архиве к работе была добавлена portable-версия Python 3.11 на 32 бита. 

Создайте пустой ```.py``` файл и добавьте в него следующий код:

``` python 
from ctypes import *
lib = CDLL('1.dll')
lib.dialog()
```

Запустите файл командой
```
ptyhon.exe 1.py
```

# Задание на самостоятельную работу

1. Изучите возможности библиотек WinAPI. Реализуйте любые 3 различных функции в своей программе (на выбор студента)
2. Исследуйте поведение функции dialog при изменении аргументов функции
3. Добавьте в функцию dialog возврат значения из регистра ```eax```. Объясните формируемые в нём значения
4. Реализуйте механизмы взаимодействия со всеми представленными языками программирования (или с любым другим, не представленным в списке)
5. Изучите механизм передачи массива в функцию. Реализуйте обработчики больших массивов (Любое дейстие, сложнее, чем ```N Log(N)``` на языках высокого уровня и на Assembler. Сравните полученные результаты
