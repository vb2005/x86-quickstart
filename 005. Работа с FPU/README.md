# Числа с плавающей точкой
Числа с плаващющей точкой являются основой большинства вычислений в современной технике. В процессорах x86 существует специальный сопроцессор FPU (Floating Point Unit), позволящий организовать работу с этими числами. Систему команд сопроцессора принято называть x87. Работа с сопроцессором x87 в чём-то похожа работу с x86. В нем также есть регистры (причем их 8 по 80 бит), также доступны операции арифметики и пересылки, но устроено все это несколько иначе. Дело в том, что регистры в x87 представлены в формате стека (первым зашел, последним ушёл) и большинство операций работает с данными на вершине стека. 

## Объявление FP-переменных 
Прежде всего, разберемся, как в RAM разместить числа с плавающей точкой? 
Это за нас автоматически сделает NASM, приводя любое дробное число к формату с плавающей точкой. Остается только указать размер:

``` asm
section .data 
i1 dd 5                ; Переменная типа Int32 i1 = 5 (поскольку точки нет)
f0 dd 5.0              ; Переменная типа Float f0 = 5
f1 dd 5.5              ; Переменная типа Float f1 = 5.5
f2 dd 10.5             ; Переменная типа Float f2 = 10.5

; Нужна большая точность?
d0 dq 3.1415           ; Переменная типа Double - 8 байт
t0 dt 9.9999           ; Переменная типа Real   - 10 байт

; Еще больше? Не поддерживаются FPU, но представимы в памяти
xx do ?                ; 128 бит
yy dy ?				         ; 256 бит
zz dz ?                ; 512 бит
```

## Передача в FPU
Теперь разберемся с тем, как передать эти значения в FPU. Для начала его необходимо проинициализировать, командой ```finit```. 
Теперь, можем грузить туда данные. Данные загружаются в вершину стека (регистр ST(0)). Данные могут быть загружены в одном из форматов: 
```
word - Float16 (Half)
dword - Float32 (Single)
qword - Float64 (Double)
tword - Float80 (Real)
```

``` asm
fld word [f1] ; Загрузка числа половинной точности Half
fld dword [f2] ; Загрузка числа одинарной точности Single
fld qword [f3] ; Загрузка числа двойной точности Double
fld tword [f4] ; Загрузка числа расширенной точности Real
```

Также можно загрузить целые числа. Сопроцессор приведет их в нужному формату
``` asm
fild word [f1] ; Загрузка целого числа word
fild dword [f2] ; Загрузка целого числа dword
fild qword [f3] ; Загрузка целого числа qword
```
Загрузить можно не только значения, но и константы. Для того, чтобы их не считать, в x87 заложены следующие коды:

``` asm
; Log_2(e)
fldl2e 

; Log_2(10)
fldl2t 

; Log_10(2)
fldlg2

; Ln(2)
fldln2

; Загрузить число PI
fldpi

; Загрузить 0
fldz

; Загрузить 1
fld1
```

## Пример ввода значений в FPU
Теперь рассмотрим программу для внесения значений в стек FPU. 
Занесем туда -1.5 в формате Float32, число Пи, значение 199 в формате Int32, число 10000 в формате Double (Float64), число -0.000001 в формате Real (Float80)

``` asm
global    _main   

section .data 
f0 dd -1.5
f1 dd 199             
f2 dq 10000.0
f3 dt -0.000001

section .text
_main:
; Инициализация
finit

; Ввод данных
fld dword [f0]
fldpi
fild dword [f1] 
fld qword [f2] 
fld tword [f3]

ret
```
Проверьте работу программы в отладчике. Для отображения регистров FPU в разлеле Регистры щелкните правой кнопкой мыши по области отображения и выберите "С плавающей точкой".

```
ST0 = -1.0000000000000000e-0006
ST1 = +1.0000000000000000e+0004
ST2 = +1.9900000000000000e+0002
ST3 = +3.1415926535897932e+0000
ST4 = -1.5000000000000000e+0000
```

## Выгрузка значений из стека FPU
Рассмотрим теперь выгрузку значений в RAM. Существует для этого два оператора: ```FIST``` и ```FISTP```. Первый выгружает число из стека в нужном формате (half, single, double, real), а второй приводит число к целому типу (short, int, long) и также извлекает в ОЗУ. Рассмотрим примеры:
```
FIST m16int
FIST m32int
FIST m64int
```
Сохраняет ST(0) с преобразованием к целому типу в RAM.
```
FISTP m16int
FISTP m32int
FISTP m64int
```
Сохраняет ST(0) с преобразованием к целому типу в RAM.
ST(0) извлекается из стека

## Основные функции FPU
Все представлены ниже математические функции не принимают на вход аргументов. Для взимодействия они используют первый и второй элементы стека.

### Простая арифметика
``` asm
FADD, FADDP
; Сложить и извлечь из стека элемент ST(0)
; ST(1) = ST(0) + ST(1)
; * Операция имеет перегрузки с различными аргументами (см. оператор FADD)

FSUB, FSUBP
; Вычесть и извлечь из стека элемент ST(0)
; ST(1) = ST(1) - ST(0)
; * Операция имеет перегрузки с различными аргументами

FSUBR, FSUBRP
; Вычесть и извлечь из стека элемент ST(0)
; ST(1) = ST(0) - ST(1)
; * Операция имеет перегрузки с различными аргументами

FDIV, FDIVP
; Разделить и извлечь из стека элемент ST(0)
; ST(1) = ST(1) / ST(0)
; * Операция имеет перегрузки с различными аргументами

FDIVR, FDIVRP
; Разделить и извлечь из стека элемент ST(0)
; ST(1) = ST(0) / ST(1)
; * Операция имеет перегрузки с различными аргументами

FMUL, FMULP
; Умножить и извлечь из стека элемент ST(0)
; ST(1) = ST(0) * ST(1)
; * Операция имеет перегрузки с различными аргументами

FABS
; модуль числа
; ST(0) = |ST(0)|

FCHS
;Изменить знак числа
;ST(0) = -ST(0)

FPREM
; Вычислить отстаток от деления  ST(0) на ST(1)
; ST(0) = ST(0) % ST(1)

FIADD, FIDIV, FIDIVR, FIMUL, FISUB, FIBUBR
; Те же самые операции, но выполняются над значениями в целых числах
```

### Логарифмы и показательные функции
``` asm
FSQRT
; Вычислить корень
; ST(0) = ST(0) ^ 0.5

FSCALE
; Умножение или деление на степени двойки
; ST(0) = ST(0) * 2 ^ ST(1)

F2XM1
; 2^X - 1
; ST(0) = 2^ST(0) - 1

FYL2X
; Вычислить y * log2(x)
; ST(1) = ST(1) * log2(ST(0))

FYL2XP1
; Вычислить y * log2(x+1)
; ST(1) = ST(1) * log2(ST(0) + 1.0)

```

### Тригонометрия
``` asm
FCOS
; Косинус
; ST(0) = COS(ST(0))

FSIN
; Синус
; ST(0) = SIN(ST(0))

FSINCOS
; Считает отдельно синус числа и косинус, загружая последний в стек
; ST(1) = SIN(ST(0))
; ST(0) = COS(ST(0))

FPATAN
; ST(1) = arctg(ST(1)/ST(0))
; Верхний элемент извлекается из стека

FPTAN
; ST(0) = tg(ST(0))
; Загрузить в ST(0) значение 1
; * Последнее требуется для упрощения вычислений обратных тригонометрических функций
```

### Другое
``` asm

FXCH
; Поменять местами два последних элемента стека
; Swap(ST(0), ST(1))

FTST
; Сформировать флаги на основе значения в ST(0)

FXTRACT
; Разделить на части мантису и порядок. Мантиса остаётся в ST(0), порядок в стек процессора x86
; ST(0) = M(ST(0))
; [SP] = P(ST(0))
; SP--

```

TODO:
Операции выгрузчи чисел
Регистр флагов
Регистр управлеия
Констансты Float
