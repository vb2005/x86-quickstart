# Начнём разработку под NASM

## Формат хранения проектов
Для выполнения работ я рекоммендую создать отедьный каталог в корне диска C:\ и в нем располагать каталоги под проекты (например, C:\asm\1).
Создайте в текущем каталоге файл 1.asm со следующим содержанием:

``` asm
global _main

section .text
_main:
    mov rax, 0x1234
    ret
``` 

В данном фрагменте кода расположена только одна секция - text. Это область программы, в которой располагаются команды. Команды удобно группировать на функции. 
Начинается функция с метки с названием функции, а заканчивается оператором ret (возврат из подпрограммы). 
Если функции планируется вызывать из внешнего кода, то обязательно стоит описать её в самом начале через оператор global и оператор export. В целом, этого будет достаточно, чтобы программа собралась. 

``` cmd
nasm -f win64 -o 1.obj
```

Но недостаточно для того, чтобы запустилась. В исполняемом файле должна быть определена точка входа. Это функция, которая будет выполнена первой. 
Мы её указываем через флаг entry. Также линковщик стоит предупредить, что формируется исполняемый консольный проект. out определяет имя выходного файла.

```
link 1.obj /entry:main /subsystem:console /out:1.exe 
```

Можете попробовать запустить полученный файл. На долю секунды откроется окно консоли с результатом. 
Чтобы более детально ознакомится с работой программы запустим её через **Visual Studio**. 
Проделайте все операции из первой работы и запустите исполняемый файл командой ![](https://img.shields.io/badge/Ctrl+F5-blue) **(Запуск без отладки)**. 
Откроется окно, в котором будет показан результат работы программы (код завершения работы - 4660). 
Дело в том, что даже программа в Windows является функцией и может возвращать значение. 
Результат работы функции в Windows берется из регистра AX (или RAX, EAX). 
А мы в данном проекте как раз туда и поместили значение **0x1234** (4660 в десятичной системе счисления). 
Теперь запустим программу с отладкой по шагам ![](https://img.shields.io/badge/F11-blue) и посмотрим на дизассемблированный код:
``` asm
00007FF643F11000  mov         eax,1234h  
00007FF643F11005  ret
```
А также на значения регистров:
```
RAX = 0000000000001234
RBX = 0000000000000000
RCX = 000000671C74C000
RDX = 00007FF643F11000
RSI = 0000000000000000
RDI = 0000000000000000
R8  = 000000671C74C000
R9  = 00007FF643F11000
R10 = 0000000000000000
R11 = 0000000000000000
R12 = 0000000000000000
R13 = 0000000000000000
R14 = 0000000000000000
R15 = 0000000000000000
RIP = 00007FF643F11005
RSP = 000000671C5FFD88
RBP = 0000000000000000
EFL = 00000244 

OV = 0 UP = 0 EI = 1 PL = 0 ZR = 1 AC = 0 PE = 1 CY = 0 
```

Если значения у Вас похожи на те, что представлены в работе, значит программа успешно выполнена.

# Основые команды x86
Рассмотрим основные (базовые) конмады x86, а также споосбы адресации их операндов:

[Требуется описание...]
## Задание на самостоятельную работу
Разработайте программу, которая выполняет вычисления по заданной формуле для своего варианта:
```
1. RAX = ((RAX / 0x10) & RCX >> 12) ^ 0xFF
2. RAX = ((RCX * 15 - 1) | 0xFFFF00) << 4
3. RAX = ((RIP & 0xFFF) & 0xFABC) ^ 0xFF
4. RAX = - (RBX * RBX) / (2 * RAX)
5. RAX = (RBX * RBX) - 4 * RAX * RCX
```
