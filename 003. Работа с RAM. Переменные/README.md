## Режимы адресации

Для доступа к данным в x86 существуют различные варианты инструкций и способов адресации. Рассмотрим различные режимы адресации на примере команды mov:

| Адресация | Пояснение | Пример команды |
| --- | --- | --- |
| Непосредственная | Работа с константой, указанной в коде команды | mov eax,1234567h |
| Регистровая | Работа со значением в регистре | mov eax,ecx |
| Прямая (абсолютная) | Прочитать из памяти по указанному в константе адресу | mov eax,[3456789h] |
| Косвено-регистровая | Прочититать из памяти, адрес ячейки которой указан в регистре |	mov eax,[ecx] |
| Базовая/индексная со смещением | Прочитать из памяти по адресу ECX+1200h | mov eax,[ecx]+1200h |
| Базовая индексная со смещением | Прочитать из памяти по адресу ECX + EDX + 40h | mov eax,[ecx][edx]+40h |
| Индексная с масштабированием и смещением | Прочитать из памяти по адресу (ESI\*4)+40h | mov eax,[esi\*4]+40h |
| Базовая индексная с масштабированием | Прочитать из памяти по адресу EDX + (ECX\*8) | mov eax,[edx][ecx\*8] |
| Базовая индексная с масштабированием и смещением | Прочитать из памяти по адресу EBX + (EDI * 2) + 20h | mov  eax,[ebx][edi*2]+20h |

Данная команда позволяет реализовать все режимы адресации. Однако большинство команд придерживается лишь небольшого числа способов адресации.

## Логические операции

Расмотрим базовые логические поразрядные операции в ассемблере x86:

| Оператор | Мнемоника | Пример |
| --- | --- | --- |
| AND | AX := AX & BX | AND AX, BX |
| OR | EAX := EAX \| 0xFFFF | OR EAX, 0xFFFF |
| XOR | RBX := RBX ^ RBX | XOR RBX, RBX |
| NOT | AL = ~AL | NOT AL |

Задание №1. Определите, какие способы адресации первого и второго операндов доступны для указанных выше команд. Оформите исследование в виде таблицы. Для поиска информации рекоммендуется использовать ресурс: https://www.club155.ru/x86cmd

Задание №2. Достаточно часто в коде можно встретить конструкцию вида ```XOR AX, AX```. Подумайте, зачем она может быть нужна и почему вместо неё не используют более очевидное действие?

## Арифметические операции

Процессор x86 уммет выполнять базовую арифметику с целыми числами:

| Оператор | Мнемоника | Пример |
| --- | --- | --- |
| ADD | AX := AX + BX | ADD AX + BX |
| SUB | EAX := EAX - 0xFFFF | SUB EAX, 0xFFFF |
| INC | RBX := RBX + 1 | INC RBX |
| DEC | [EAX] = [EAX] - 1 | DEC [EAX] |
| NEG | RAX := -RAX | NEG RAX

Задание №3. Самостоятельно рассмотрите способы предсталвения операндов и адресацию у команд ```IDIV``` и ```IMUL```. 
Найдите осаток от деления года на произведения дня и месяца. В качестве исходных данных возьмите Вашу дату рождения.

## Сдвиговые операции

| Оператор | Мнемоника | Пример |
| --- | --- | --- |
| SAR | AX := AX * 2^CL^ | SAR AX, CL |
| SAL | AX := AX / 2^CL^ | SAL AX, CL |
| SHR | Логич. сдвиг вправо | SHR AX, CL |
| SHL | Логич. сдвиг влево | SHL AX, CL |
| ROR | Цикл. сдвиг вправо | ROR AX, CL |
| ROL | Цикл. сдвиг влево | ROL AX, CL |

Задание №4. Объясните, как при помощи сдвиговых операций сдвига и сложения осуществить умножение на 3?

## Объявление переменных и констант

В коде принято размещать данные в отдельной секции (секция ```.data```), а если данные неизменяемые, то в секции ```.rodata.``` 
При объявлении переменной указывается её имя, тип и значение по-умолчанию.

``` asm
.data
var1 db 255
.rodata
mask dw 0xFF00
```

В x86 поддерживаются следующие типы переменных:

| Тип | Аналог в C++ | Размер |
| --- | --- | --- |
| db | char | 1 байт |
| dw | short | 2 байта |
| dd | int | 4 байта |
| dq | long | 8 байт |

Сразу рассмотрим простейшие примеры работы с переменными:



* Любопытное замечание: Переменная в ассемблере есть ни что иное, как метка, после которой некоторое количество байт идет с интересующим нас значением. Таким образом, мы можем "выполнить" переменную или прочитать код команды в регистр *


Хотя на самом деле мы можем размещать переменные в любом месте программы, поскольку и команды, и данные в оперативной памяти будут лежать в одном и том же месте. Главное, самим не перепутать, и не попытаться «выполнить» переменную (результат гарантированно будет непредсказуемым).   

Чтение, запись ячеек через абсолютные адреса и через относительные



## Динамическое выделение RAM
В некоторых ситуациях может пригодится дианмическое выделение памяти, когда заранее узнать 
требуемый объем RAM невозможно. При монопольном уровне доступа к памяти, 
когда мы работем за пределами контекста ОС мы можем адресовать и использовать 
по своему назначению практически любую ячейку памяти, обратившись к ней по адресу. 
Провернуть такой трюк в ОС у вас не выйдет. Попытка произвольного доступа к случайной 
ячейке за пределами программы приведет к отказу в доступе. 

Поэтому, чтобы получить больше RAM нам надо попросить её у ОС. 
Сделать это можно функциями библиотеки **kernel32**.


## Функция HeapAlloc (heapapi.h)

Выделяет требуемое число байт оперативной памяти в куче
``` cpp
DECLSPEC_ALLOCATOR LPVOID HeapAlloc(
  [in] HANDLE hHeap,
  [in] DWORD  dwFlags,
  [in] SIZE_T dwBytes
);
```

### Аргументы функции
```
[in] hHeap
```
Дескриптор кучи, из которой будет выделена память. Этот дескриптор возвращается функцией HeapCreate или GetProcessHeap .
```
[in] dwFlags
```
Параметры выделения кучи. При указании любого из этих значений будет переопределено соответствующее значение, указанное при создании кучи с помощью HeapCreate. Этот параметр может быть одним или несколькими из следующих значений.
Мы делаем его равным 8, чтобы выделить память и заполнить её нулевыми значениями
```
[in] SIZE_T dwBytes
```
Если функция завершается сбоем и вы не указали ```HEAP_GENERATE_EXCEPTIONS```, возвращаемое значение равно ```NULL```.
Если функция выполняется успешно, возвращаемое значение ```EAX``` является указателем на выделенный блок памяти.

Таким образом, чтобы вызвать эту функцию необходимо предварительно найти дескритптор кучи. Сделать это можно функцией GetProcessHeap

## Функция GetProcessHeap (heapapi.h)

Извлекает дескриптор кучи по умолчанию вызывающего процесса в ```EAX```. Затем этот дескриптор можно использовать в последующих вызовах функций кучи.

``` cpp
HANDLE GetProcessHeap();
```

### Пример выделения динамической памяти

Рассмотрим выделение памяти, объёмом 1 ГБ при помощи указанных выше функций:
``` asm
    global _main

    ; те самые функции из библиотеки kernel32.lib
    extern _GetProcessHeap@0
    extern _HeapAlloc@12

    section .text
_main:

    call _GetProcessHeap@0  ; Находим расположение кучи (в регистр EAX)

    ; Передаем аргументы в функцию через стек в обратном порядке
    push 1000000000         ; 1 ГБ RAM
    push 8                  ; Заполняем нулями
    push eax                ; Указатель кучи
    call _HeapAlloc@12      ; Вызов функции выделения (адрес указателя на первый элемент в EAX)
    ret
```

Важно! указанные выше функции описаны для библиотек ОС Windows x86-32. Сборка данного проекта осуществляется в разрядности x86-32:
```
nasm -f win32 lab_2_3.asm -o lab_2_3.obj
link lab_2_3.obj /entry:main /subsystem:console /lab_2_3.exe kernel32.lib user32.lib
```

Выполните отладку, убедитесь, что память была выделена (например, через диспетчер задач)
